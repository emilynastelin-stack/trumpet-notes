---
import Layout from '../layouts/Layout.astro';

const serverImages = [
  'C1.png',
  'D1.png',
  'E1.png',
  'F1.png',
  'G1.png',
  'A1.png',
  'B1.png',
  'G0.png',
  'A0.png',
  'B0.png',
  'C2.png',
  'D2.png',
  'E2.png',
  'F2.png',
  'G2.png',
  'Gsharp0.png', 'Asharp0.png', 'Csharp1.png', 'Dsharp1.png', 'Fsharp1.png', 'Gsharp1.png', 'Asharp1.png', 'Csharp2.png', 'Dsharp2.png', 'Fsharp2.png', 'Gsharp2.png',
  'Gflat0.png', 'Aflat0.png', 'Bflat0.png', 'Dflat1.png', 'Eflat1.png', 'Gflat1.png', 'Aflat1.png', 'Bflat1.png', 'Dflat2.png', 'Eflat2.png', 'Gflat2.png'
];

const initialImage = serverImages[Math.floor(Math.random() * serverImages.length)];
---

<Layout>
  <main style="display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; padding:2rem; box-sizing:border-box; background: #1f1c2c; color: white; position:relative;">
    
    <!-- Fingering Image -->
    <img
      id="fingeringImg"
      class="fingering-img"
      src={`/assets/images/${initialImage}`}
      data-images={JSON.stringify(serverImages)}
      data-initial={initialImage}
      alt="Random Fingering"
      tabindex="0"
      role="img"
      aria-label="Random fingering image"
      style="max-width:300px; width:80%; border-radius:1rem; box-shadow:0 8px 20px rgba(0,0,0,0.5); margin-bottom:2rem; outline:none;"
    />

    <!-- Streak display -->
  <div id="streak" style="position: absolute; top: 20px; right: 100px; background: rgba(0,0,0,0.36); color: #fff; padding: 0.5rem 0.75rem; border-radius: 10px; font-weight:700; box-shadow: 0 6px 18px rgba(0,0,0,0.6);">
      Streak: <span id="streak-value">0</span> 
      <small style="opacity:0.8; margin-left:6px;">Best: <span id="best-value">0</span></small>
    </div>

    <!-- Lives display for Marathon: musical note icons -->
    <div id="lives" aria-hidden="false" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.12); color: #fff; padding: 0.25rem 0.5rem; border-radius: 10px; font-weight:700; box-shadow: 0 6px 18px rgba(0,0,0,0.12); display:flex; gap:10px; align-items:center;">
      <span class="life-note" data-life="1" aria-hidden="false" style="font-size:28px;">â™ª</span>
      <span class="life-note" data-life="2" aria-hidden="false" style="font-size:28px;">â™ª</span>
      <span class="life-note" data-life="3" aria-hidden="false" style="font-size:28px;">â™ª</span>
    </div>
    <!-- Accessible live region for announcements -->
    <div id="live-announcer" aria-live="polite" aria-atomic="true" style="position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden;"> </div>

    <!-- Run results / Game Over overlay -->
    <div id="run-overlay" style="display:none; position: absolute; inset:0; background: rgba(0,0,0,0.72); align-items:center; justify-content:center;">
      <div id="run-panel" style="background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); color: white; padding: 2rem; border-radius: 12px; text-align:center; width: min(420px, 90%); box-shadow: 0 18px 60px rgba(2,6,23,0.6);">
        <h2 id="run-title" style="margin:0 0 8px 0; font-size:1.6rem;">Results</h2>
        <p id="run-msg" style="margin:0.25rem 0 1rem 0; font-size:1.05rem; opacity:0.95;">You finished the run.</p>
        <div style="font-size:1.4rem; font-weight:800; margin-bottom:0.25rem;">Score: <span id="run-score">0 / 0</span></div>
        <div id="run-highscore" style="font-size:0.95rem; opacity:0.95; margin-bottom:0.5rem; display:flex; gap:0.5rem; align-items:center; justify-content:center;">
          <div>Best: <span id="run-best">0</span></div>
          <div id="new-high-badge" style="display:none; background:linear-gradient(90deg,#f43f5e,#fb7185); color:white; padding:0.25rem 0.5rem; border-radius:8px; font-weight:800; box-shadow:0 8px 24px rgba(244,63,94,0.18);">NEW HIGH</div>
        </div>
        <div style="display:flex; gap:0.5rem; justify-content:center;">
          <button id="run-restart" class="gp-btn" style="padding:0.6rem 1rem; border-radius:8px;">Restart</button>
          <button id="run-close" class="gp-btn" style="padding:0.6rem 1rem; border-radius:8px; background: linear-gradient(90deg,#6b7280,#374151);">Close</button>
        </div>
      </div>
    </div>

    <!-- Gamepad -->
    <div id="gamepad" style="display:flex; flex-direction:column; align-items:center; gap:0.6rem; margin-top:1.25rem;">
      <div style="display:flex; gap:0.6rem;">
       <button data-button="1" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">1</button>
       <button data-button="2" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">2</button>
       <button data-button="3" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">3</button>
      </div>
      <button data-button="0" id="gp-zero" class="gp-btn" style="width:320px; height:80px; border-radius:40px;">0</button>
    </div>

    <!-- Test controls removed (shake test) -->

    <style>
      :root{
        --anim-pop: 680ms;
        --anim-correct: 700ms;
        --anim-confetti: 1000ms;
        --anim-shake: 200ms; /* faster shake */
        --anim-wrong-glow: 360ms;
        --anim-safety: 420ms;
        --reveal-duration: 2500ms;
        --press-duration: 120ms;
      }
    /* Image animations */
    /* Temporarily disable base transition so shake keyframes are fully visible while testing */
    .fingering-img { /* transition: transform 320ms ease, opacity 320ms ease, filter 320ms ease; */ cursor:pointer; }
  .fingering-anim { animation: popRotateHue var(--anim-pop) cubic-bezier(.2,.9,.3,1); box-shadow: 0 30px 80px rgba(14,165,164,0.35) !important; border-radius:1rem; transform-origin:50% 60%; }
    @keyframes popRotateHue { 0%{transform:scale(0.88) rotate(-12deg);opacity:0;}50%{transform:scale(1.14) rotate(8deg);opacity:1;}100%{transform:scale(1) rotate(0deg);opacity:1;} }

      /* Correct combo: pop + hue flash + confetti */
  .correct-anim { animation: correctPop var(--anim-correct) ease-out forwards; transform-origin:50% 60%; }
      @keyframes correctPop { 0%{transform:scale(1) rotate(0deg);filter:hue-rotate(0deg) saturate(1);} 50%{transform:scale(1.18) rotate(5deg);filter:hue-rotate(90deg) saturate(1.4);}100%{transform:scale(1) rotate(0deg);filter:hue-rotate(0deg) saturate(1);} }

      /* Confetti */
  .confetti { position:absolute; bottom:40%; width:6px; height:6px; border-radius:50%; pointer-events:none; transform:translateY(0) scale(1); animation: confettiRise var(--anim-confetti) ease-out forwards; opacity:0.9; }
      @keyframes confettiRise { 0%{transform:translateY(0) rotate(0deg) scale(0.8); opacity:1;} 50%{transform:translateY(-80px) rotate(180deg) scale(1.1); opacity:0.9;} 100%{transform:translateY(-140px) rotate(360deg) scale(1); opacity:0;} }

      /* Shake for wrong combo: fast left-right oscillation (no hinge) */
      @keyframes shakeX {
        0% { transform: translateX(0); }
        10% { transform: translateX(-25px); }
        20% { transform: translateX(25px); }
        30% { transform: translateX(-20px); }
        40% { transform: translateX(20px); }
        50% { transform: translateX(-15px); }
        60% { transform: translateX(15px); }
        70% { transform: translateX(-10px); }
        80% { transform: translateX(10px); }
        90% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
      }
      /* stronger, more visible shake for testing */
  .shake { animation: shakeX 400ms ease-in-out 1 !important; transition: none !important; will-change: transform; }
  /* ensure transition doesn't smooth out the keyframe and hint the GPU to optimize */
  img.fingering-img.shake { /* transition: none !important; */ will-change: transform; }

      /* Gamepad */
        .gp-btn {
          background:#0ea5a4; color:white; border:none; font-weight:800; font-size:1.35rem;
          display:inline-flex; align-items:center; justify-content:center; cursor:pointer;
          box-shadow: 0 8px 22px rgba(2,6,23,0.35);
          transition: transform 160ms ease, box-shadow 160ms ease;
          touch-action: manipulation;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        .gp-btn:active { transform: translateY(3px) scale(0.985); box-shadow: 0 6px 16px rgba(2,6,23,0.28); }
        #gp-zero:active { transform: translateY(3px) scale(0.992); }

        /* immediate pressed state (for quick tactile feedback) */
        .gp-pressed { transform: translateY(2px) scale(0.975); box-shadow: 0 4px 10px rgba(2,6,23,0.25) !important; }

  /* button flash for wrong attempts */
  .gp-wrong { background: linear-gradient(90deg,#ef4444,#f97316) !important; color: white !important; transform: scale(1.02) !important; box-shadow: 0 10px 36px rgba(239,68,68,0.65) !important; }

        /* red glow for wrong answer (stronger, higher specificity) */
        @keyframes wrongGlow {
          0% { box-shadow: 0 0 0 rgba(239,68,68,0); filter: saturate(1); }
          40% { box-shadow: 0 0 36px rgba(239,68,68,1); filter: saturate(1.25); }
          100% { box-shadow: 0 0 0 rgba(239,68,68,0); filter: saturate(1); }
        }
    /* align duration with shake so they occur together */
  /* Run both the glow and the shake together so one doesn't override the other */
  img.fingering-img.wrong-glow { animation: wrongGlow var(--anim-wrong-glow) ease forwards, shakeX var(--anim-shake) ease-in-out 1; box-shadow: 0 0 36px rgba(239,68,68,0.95) !important; border: 3px solid rgba(239,68,68,0.65) !important; }

        /* responsive: scale down on very small screens */
        @media (max-width:420px) {
          .gp-btn { font-size:1.05rem; }
          #gp-zero { width: 260px !important; height: 68px !important; }
          #gamepad > div button { width:80px !important; height:80px !important; }
        }
      .gp-btn:active,#gp-zero:active{transform:translateY(2px) scale(0.98);}
      .gp-hint { box-shadow:0 10px 30px rgba(250,204,21,0.9); transform:scale(1.08); background:linear-gradient(90deg,#f59e0b,#fbbf24); color:#111827 !important; }

      /* Streak pulse */
      @keyframes streakPulse { 0%{transform:scale(1);}40%{transform:scale(1.08);box-shadow:0 18px 48px rgba(14,165,164,0.28);}100%{transform:scale(1);} }
      .streak-pulse { animation: streakPulse 720ms cubic-bezier(.2,.9,.3,1); }

      /* Bubbles (optional) */
      .bubble { position:absolute; bottom:40%; border-radius:50%; pointer-events:none; transform:translateY(0) scale(0.6); animation:bubbleRise 900ms cubic-bezier(.2,.9,.3,1) forwards; opacity:0.95; mix-blend-mode:screen; box-shadow:0 10px 40px rgba(14,165,164,0.35); }
      @keyframes bubbleRise {0%{transform:translateY(0) scale(0.6);opacity:0.95;}60%{transform:translateY(-90px) scale(1.05);opacity:0.9;}100%{transform:translateY(-140px) scale(1.25);opacity:0;}}

      /* Life note styles and explosion */
  #lives .life-note { display:inline-block; color:#ffecb3; opacity:1; transform-origin:center; transition: transform 200ms ease, opacity 220ms ease; font-weight:700; font-size:28px; }
  #lives .life-note.pop-explode { animation: lifePop 380ms cubic-bezier(.2,.9,.3,1) forwards; }
      @keyframes lifePop { 0% { transform: scale(1) rotate(0deg); opacity:1; } 60% { transform: scale(1.8) rotate(12deg); opacity:0.95; } 100% { transform: scale(0.2) rotate(50deg); opacity:0; } }

  /* particle styles - SVG note container */
  .life-confetti { position:fixed; width:14px; height:18px; pointer-events:none; opacity:1; transform:translate(0,0) rotate(0deg) scale(1); z-index:99999; filter: drop-shadow(0 8px 18px rgba(0,0,0,0.35)); will-change: transform, opacity; }
  .life-confetti .note-svg { width:100%; height:100%; display:block; }
  .life-confetti.big { width:22px; height:30px; }
  /* small particle used for pop-burst on lives */
  .life-particle { position: fixed; width:10px; height:10px; border-radius:50%; pointer-events:none; z-index:100200; will-change: transform, opacity; }
  /* ðŸ”´ Balloon Pop Effect (pop-burst) */
  @keyframes pop-burst {
    0% { transform: scale(1); filter: hue-rotate(0deg); opacity: 1; }
    40% { transform: scale(1.3); filter: hue-rotate(20deg); }
    60% { transform: scale(0.8); filter: hue-rotate(-20deg); }
    100% { transform: scale(0); opacity: 0; filter: blur(5px) hue-rotate(120deg); }
  }
  .pop-burst { animation: pop-burst 0.6s ease-out forwards; transform-origin: center; }
  /* New high badge animation */
  @keyframes badge-pop { 0%{transform:scale(0.6);opacity:0;}60%{transform:scale(1.08);opacity:1;}100%{transform:scale(1);opacity:1;} }
  #new-high-badge.show { display:inline-block; animation: badge-pop 420ms cubic-bezier(.2,.9,.3,1) forwards; }
  /* overlay flash */
  #life-explosion-layer.flash {
    animation: layerFlash 220ms ease-out 1;
  }
  @keyframes layerFlash { 0%{ background: rgba(255,255,255,0); } 50%{ background: rgba(255,255,255,0.08); } 100%{ background: rgba(255,255,255,0); } }
  /* light shake on overlay to make explosion dramatic (only overlay moves) */
  #life-explosion-layer.shake { animation: layerShake 420ms cubic-bezier(.2,.9,.3,1); }
  @keyframes layerShake {
    0% { transform: translateX(0); }
    20% { transform: translateX(-8px) rotate(-0.6deg); }
    40% { transform: translateX(10px) rotate(0.8deg); }
    60% { transform: translateX(-6px) rotate(-0.4deg); }
    80% { transform: translateX(4px) rotate(0.25deg); }
    100% { transform: translateX(0); }
  }
    </style>
  </main>

  <script>
    // @ts-nocheck
    (function(){
      /** @type {HTMLImageElement | null} */
      const img = /** @type {HTMLImageElement | null} */ (document.getElementById('fingeringImg'));
      if(!img) return;

      // Notes with combos and frequency weights. We'll build a weighted draw pile below.
      /** @type {{name:string,combo:string[],freq:number}[]} */
      const notes = [
        { name: "G0.png", combo: ["1","3"], freq: 1 },
        { name: "A0.png", combo: ["1","2"], freq: 1 },
        { name: "B0.png", combo: ["2"], freq: 1 },
        { name: "C1.png", combo: ["0"], freq: 1 },
        { name: "D1.png", combo: ["1","3"], freq: 1 },
        { name: "E1.png", combo: ["1","2"], freq: 1 },
        { name: "F1.png", combo: ["1"], freq: 1 },
        { name: "G1.png", combo: ["0"], freq: 1 },
        { name: "A1.png", combo: ["1","2"], freq: 1 },
        { name: "B1.png", combo: ["2"], freq: 1 },
        { name: "C2.png", combo: ["0"], freq: 1 },
        { name: "D2.png", combo: ["1"], freq: 1 },
        { name: "E2.png", combo: ["0"], freq: 1 },
        { name: "F2.png", combo: ["1"], freq: 1 },
        { name: "G2.png", combo: ["0"], freq: 1 },
        { name: "Fsharp0.png", combo: ["1","2","3"], freq: 3 },
        { name: "Gsharp0.png", combo: ["2","3"], freq: 3 },
        { name: "Asharp0.png", combo: ["1"], freq: 3 },
        { name: "Csharp1.png", combo: ["1","2","3"], freq: 1 },
        { name: "Dsharp1.png", combo: ["2","3"], freq: 2 },
        { name: "Fsharp1.png", combo: ["2"], freq: 1 },
        { name: "Gsharp1.png", combo: ["2","3"], freq: 2 },
        { name: "Asharp1.png", combo: ["1"], freq: 2 },
        { name: "Csharp2.png", combo: ["1","2"], freq: 2 },
        { name: "Dsharp2.png", combo: ["2"], freq: 3 },
        { name: "Fsharp2.png", combo: ["2"], freq: 2 },
        { name: "Gsharp2.png", combo: ["2","3"], freq: 3 },
        { name: "Gflat0.png", combo: ["1","2","3"], freq: 3 },
        { name: "Aflat0.png", combo: ["2","3"], freq: 2 },
        { name: "Bflat0.png", combo: ["1"], freq: 1 },
        { name: "Dflat1.png", combo: ["1","2","3"], freq: 2 },
        { name: "Eflat1.png", combo: ["2","3"], freq: 1 },
        { name: "Gflat1.png", combo: ["2"], freq: 3 },
        { name: "Aflat1.png", combo: ["2","3"], freq: 2 },
        { name: "Bflat1.png", combo: ["1"], freq: 1 },
        { name: "Dflat2.png", combo: ["1","2"], freq: 2 },
        { name: "Eflat2.png", combo: ["2"], freq: 1 },
        { name: "Gflat2.png", combo: ["2"], freq: 3 }
      ];

      // Build mapping name -> combo for quick lookup
      /** @type {{[key:string]: string[]}} */
      const answerKey = {};
      notes.forEach(n=>{ answerKey[n.name] = n.combo.slice(); });

        // Run tracking (25-card runs)
        let runCount = 0;
        let runCorrect = 0;
        const RUN_LIMIT = 25;

      // Image filename list (unique names)
      /** @type {string[]} */
      let images = notes.map(n=>n.name);
      /** @type {number} */
      let currentIndex = images.indexOf(String(img.dataset.initial || images[0] || '')) || 0;

      // Build a weighted name array for the draw pile (more copies = more common)
      /** @type {string[]} */
      const weightedNames = [];
      notes.forEach(note => {
        // weight: 1 = most frequent -> 3 copies, 3 = least -> 1 copy
        const weight = Math.max(1, 4 - (note.freq || 1));
        for (let i = 0; i < weight; i++) weightedNames.push(note.name);
      });

  /** @type {Set<string>} */
  const activeKeys = new Set();
  /** @type {{key:string,time:number}[]} */
  const recentPresses = [];
  // make detection snappier for quicker UX; small but allows multi-key simultaneity
  const TOUCH_WINDOW = 120;
  // Read CSS timing variables (return milliseconds)
  function cssMs(varName, fallbackMs){
    try{
      const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '';
      if(!v) return fallbackMs;
      if(v.endsWith('ms')) return parseFloat(v.replace('ms',''));
      if(v.endsWith('s')) return parseFloat(v.replace('s',''))*1000;
      return fallbackMs;
    }catch(e){return fallbackMs;}
  }
  const ANIM_POP = cssMs('--anim-pop', 680);
  const ANIM_CORRECT = cssMs('--anim-correct', 700);
  const ANIM_CONFETTI = cssMs('--anim-confetti', 1000);
  const ANIM_SHAKE = cssMs('--anim-shake', 360);
  const ANIM_WRONG_GLOW = cssMs('--anim-wrong-glow', 360);
  const ANIM_SAFETY = cssMs('--anim-safety', 420);
  const REVEAL_DURATION = cssMs('--reveal-duration', 2500);
  const PRESS_DURATION = cssMs('--press-duration', 120);
  /** @type {number|null} */
  let wrongTimeout = null;
    /** @type {{[k:string]:number}} */
    const wrongCounts = {};
  /** @type {number|null} */
  let revealTimeout = null;
  // track when the last correct animation started/ended to avoid overlapping wrong visuals
  let lastCorrectAt = 0;
      let streak = parseInt(localStorage.getItem('fingering-streak')||'0',10)||0;
      let best = parseInt(localStorage.getItem('fingering-best')||'0',10)||0;
      const streakEl = document.getElementById('streak-value');
      const bestEl = document.getElementById('best-value');
    if(streakEl) streakEl.textContent = String(streak);
    if(bestEl) bestEl.textContent = String(best);

      /** @param {number} idx */
      function setImage(idx){
        // clear any visible hints when switching cards
        clearHints();
        const filename = images[idx];
        const url = `/assets/images/${encodeURIComponent(filename)}`;
        const pre = new Image();
        pre.src = url;
        pre.onload = ()=>{ if(img) img.src = url; }
      }

      function clearHints(){
        try{
          const buttons = document.querySelectorAll('#gamepad [data-button]');
          buttons.forEach(b=>b.classList.remove('gp-hint'));
        }catch(e){}
        if(revealTimeout){ clearTimeout(revealTimeout); revealTimeout = null; }
      }

      // Shuffle helper (Fisher-Yates)
      /** @param {string[]} a */
      function shuffleArray(a){
        const arr = a.slice();
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      // Draw pile: use weightedNames for a weighted random presentation
      let drawPile = shuffleArray(weightedNames.slice());
      // remove the initial image occurrence(s) from the pile to avoid immediate repeat
      (function removeInitialFromPile(){
        const init = String(images[currentIndex] || img.dataset.initial || '');
        // remove all occurrences of the initial filename from the weighted pile
        drawPile = drawPile.filter(n => n !== init);
      })();

      function pickNextRandom(){
        if(drawPile.length === 0) drawPile = shuffleArray(weightedNames.slice());
        // pop from the end for efficiency
        let nextFile = drawPile.pop();
        // avoid immediate repeat if possible
        if(images.length>1 && nextFile === images[currentIndex]){
          // try to take another; push the same file back to front
          drawPile.unshift(nextFile);
          nextFile = drawPile.pop();
        }
        // find the index in the canonical images list (first occurrence)
        const idx = images.indexOf(nextFile);
        if(idx>=0) {
          currentIndex = idx;
          setImage(currentIndex);
        } else {
          // fallback: if not found (shouldn't happen), pick a random index
          currentIndex = Math.floor(Math.random()*images.length);
          setImage(currentIndex);
        }
      }

      function advanceToNext(){ pickNextRandom(); }

      function triggerCorrect(){
        if(!img) return;
        img.classList.remove('correct-anim');
        void img.offsetWidth;
        img.classList.add('correct-anim');
        lastCorrectAt = Date.now();
  for(let i=0;i<5;i++){spawnConfetti(i*40);}
        runCount++;
        runCorrect++;
        checkRunCompleteIfNeeded();
  setTimeout(()=>{ if(img) img.classList.remove('correct-anim'); }, ANIM_CORRECT);
      }

      /** @param {number} [delay] */
      function spawnConfetti(delay=0){
        setTimeout(()=>{
          const conf = document.createElement('div');
          conf.classList.add('confetti');
          conf.style.left = `${Math.random()*80+10}%`;
          conf.style.backgroundColor = `hsl(${Math.random()*360},70%,60%)`;
          if(img && img.parentElement) img.parentElement.appendChild(conf);
    setTimeout(()=>conf.remove(), ANIM_CONFETTI);
        }, delay);
      }

  // Spawn a brief pop-burst using SVG-note particles near a life-note element
      function getExplosionLayer(){
        try{
          let layer = document.getElementById('life-explosion-layer');
          if(layer) return layer;
          layer = document.createElement('div');
          layer.id = 'life-explosion-layer';
          // full-viewport fixed overlay, pointer-events none so it can't capture input
          Object.assign(layer.style, {
            position: 'fixed', inset: '0px', pointerEvents: 'none', zIndex: '9999', overflow: 'visible'
          });
          document.body.appendChild(layer);
          return layer;
        }catch(e){ return document.body; }
      }

      function spawnLifeExplosion(el){
        try{
          if(!el || !el.getBoundingClientRect) return;
          const rect = el.getBoundingClientRect();
          const layer = getExplosionLayer();

          // small flash only
          layer.classList.add('flash');
          setTimeout(()=>{ layer.classList.remove('flash'); }, 220);

          // clone the life note into the overlay and play pop-burst
          const clone = /** @type {HTMLElement} */ (el.cloneNode(true));
          clone.style.position = 'fixed';
          clone.style.left = Math.round(rect.left) + 'px';
          clone.style.top = Math.round(rect.top) + 'px';
          clone.style.zIndex = '100150';
          clone.style.margin = '0';
          clone.style.pointerEvents = 'none';
          clone.style.transformOrigin = 'center';
          clone.style.display = 'inline-flex';
          clone.style.alignItems = 'center';
          clone.style.justifyContent = 'center';
          clone.classList.add('pop-burst');
          layer.appendChild(clone);

          // small colorful particle burst (8 pieces)
          const particleCount = 8;
          for(let i=0;i<particleCount;i++){
            const p = document.createElement('div');
            p.className = 'life-particle';
            p.style.left = Math.round(rect.left + rect.width/2) + 'px';
            p.style.top = Math.round(rect.top + rect.height/2) + 'px';
            p.style.backgroundColor = `hsl(${Math.random()*360},70%,60%)`;
            layer.appendChild(p);
            const angle = Math.random()*Math.PI*2;
            const dist = 48 + Math.random()*88;
            const dx = Math.cos(angle)*dist;
            const dy = Math.sin(angle)*dist - (6 + Math.random()*8);
            p.style.transform = 'translate(0px,0px) scale(1)';
            p.style.transition = (360 + Math.random()*320) + 'ms cubic-bezier(.2,.9,.3,1)';
            requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ p.style.transform = `translate(${dx}px, ${dy}px) scale(${0.6 + Math.random()*0.6})`; p.style.opacity = '0'; }); });
            setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 900 + Math.random()*400);
          }

          // remove clone after animation
          setTimeout(()=>{ try{ clone.remove(); }catch(e){} }, 680);
        }catch(e){ console.warn('spawnLifeExplosion failed', e); }
      }

      function triggerShake(){
        // kept for compatibility: use the synchronized triggerWrongVisual for combined visuals
        if(!img) return;
        img.classList.remove('shake');
        void img.offsetWidth;
        img.classList.add('shake');
  setTimeout(()=>{ if(img) img.classList.remove('shake'); }, ANIM_SHAKE + 40);
      }

      // Add wrong visual (red glow + shake) using forced reflow to reliably restart animations
      /** @param {HTMLElement|null} pressedBtn */
      function triggerWrongVisual(pressedBtn){
        // If a correct animation started very recently, skip wrong visuals to avoid overlap
        const now = Date.now();
        if (now - lastCorrectAt < 500) {
          console.log('[fingering] triggerWrongVisual ignored due to recent correct at', lastCorrectAt, 'now', now);
          return;
        }
        const filename = images[currentIndex];
        wrongCounts[filename] = (wrongCounts[filename] || 0) + 1;

  // Remove only the relevant classes and any pressed indicator
  if(img) img.classList.remove('wrong-glow', 'shake');
  if (pressedBtn) pressedBtn.classList.remove('gp-wrong', 'gp-pressed');

        // Force a reflow so the browser recognizes the class removal
        if(img) void img.offsetWidth;

  // Start both wrong glow and shake (red image glow + button flash)
  if(img) img.classList.add('wrong-glow', 'shake');
  if (pressedBtn) pressedBtn.classList.add('gp-wrong');

  console.log('[fingering] triggerWrongVisual applied classes', img?.className);

        // Try to trigger a short haptic/vibration on supported mobile devices
        try{
          if(typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function'){
            // short buzz to indicate wrong answer
            const pattern = 60;
            navigator.vibrate(pattern);
            // expose a debug trace for DevTools: last haptic and an event
            try{ window.__lastHaptic = { time: Date.now(), pattern: pattern, file: filename }; }catch(e){}
            try{ console.info('[fingering] haptic fired', { pattern, filename }); }catch(e){}
            try{ window.dispatchEvent(new CustomEvent('fingering:haptic', { detail: { pattern, filename, time: Date.now() } })); }catch(e){}
          }
        }catch(e){}

        // Remove when the animation finishes. Use animationend for reliability,
        // with a forced fallback that sets inline animation to 'none' then removes classes.
        let cleaned = false;
        const cleanup = () => {
          if (cleaned) return;
          cleaned = true;
          if(img) img.classList.remove('wrong-glow', 'shake');
          if (pressedBtn) pressedBtn.classList.remove('gp-wrong', 'gp-pressed');
          if(img) img.removeEventListener('animationend', cleanup);
          // clear inline animation override if any
          try { img.style.animation = ''; } catch (e) {}
          console.log('[fingering] triggerWrongVisual cleaned up classes', img?.className);
        };
        if(img) img.addEventListener('animationend', cleanup, { once: true });

  // Safety fallback: force stop the animation and cleanup after anim safety ms
  const safety = setTimeout(() => {
          if (!cleaned) {
            try { img.style.animation = 'none'; } catch (e) {}
            // force reflow to flush the inline animation change
            if(img) void img.offsetWidth;
            cleanup();
          }
          clearTimeout(safety);
        }, ANIM_SAFETY);

        // reset streak
        streak = 0; try { localStorage.setItem('fingering-streak','0'); } catch(e){}
        if (streakEl) streakEl.textContent = '0';
  // Do not reveal the correct combo automatically in Marathon mode; keep wrongCounts but don't reveal
  if ((wrongCounts[filename]||0) >= 3) { wrongCounts[filename] = 0; }
        runCount++;
        // decrement lives for Marathon mode and update musical note icons
        try{
          if(typeof lives !== 'undefined'){
            const prevLives = lives;
            lives = Math.max(0, lives-1);
            // hide the right-most visible life note so icons disappear in order
            try{
              const notes = Array.from(document.querySelectorAll('#lives .life-note'));
              for(let i = notes.length - 1; i >= 0; i--){
                const el = notes[i];
                const op = window.getComputedStyle ? window.getComputedStyle(el).opacity : el.style.opacity;
                if(!op || parseFloat(op) > 0.15){
                  // spawn an exploding clone so the original element isn't transformed (prevents page shift)
                  spawnLifeExplosion(el);
                  // mark the original as gone after the animation completes
                  setTimeout(()=>{ try{ el.style.opacity='0.0'; }catch(e){} }, 420);
                  break;
                }
              }
            }catch(e){ console.warn('life icon update failed', e); }
            const announcer = document.getElementById('live-announcer');
            if(announcer) announcer.textContent = `Lives remaining: ${lives}`;
            // If the user just dropped to zero, allow them to keep playing until their next mistake.
            // Set outOfLives flag so a subsequent wrong will end the run.
            if(lives <= 0){
              if(typeof window.__outOfLives === 'undefined' || !window.__outOfLives){
                window.__outOfLives = true;
                if(announcer) announcer.textContent = `You are out of lives. One more mistake will end the run.`;
              } else {
                // already out of lives and made another mistake: end game
                onGameOver();
                return;
              }
            } else {
              // regained or still have lives
              window.__outOfLives = false;
            }
          }
        }catch(e){}
        checkRunCompleteIfNeeded();
      }

      function showRunOverlay(){
        const overlay = document.getElementById('run-overlay');
        const scoreEl = document.getElementById('run-score');
        const bestEl = document.getElementById('run-best');
        const msg = document.getElementById('run-msg');
        const title = document.getElementById('run-title');
        if(!overlay || !scoreEl) return;
        const correct = runCorrect;
        const total = runCount;
  scoreEl.textContent = `${correct} / ${total}`;
  const pct = Math.round((correct / Math.max(1, total)) * 100);
        try{
          const key = 'marathon-best';
          const prev = parseInt(localStorage.getItem(key)||'0',10) || 0;
          const bestElNode = bestEl;
          const badge = document.getElementById('new-high-badge');
          if(correct > prev){ localStorage.setItem(key, String(correct)); if(bestElNode) bestElNode.textContent = String(correct); if(badge){ badge.classList.add('show'); badge.style.display='inline-block'; setTimeout(()=>{ badge.classList.remove('show'); }, 1400); } }
          else { if(bestElNode) bestElNode.textContent = String(prev); }
        }catch(e){}
        if(pct >= 85){
          title.textContent = 'Great job!';
          msg.textContent = 'You scored ' + pct + '%. ðŸŽ‰';
          for(let i=0;i<12;i++) spawnConfetti(i*30);
        } else {
          title.textContent = 'Run complete';
          msg.textContent = 'You scored ' + pct + '%. Keep practicing!';
        }
        overlay.style.display = 'flex';
  const restart = document.getElementById('run-restart');
  const close = document.getElementById('run-close');
  if(restart) restart.onclick = () => { overlay.style.display = 'none'; runCount = 0; runCorrect = 0; lives = 3; try { resetLifeIcons(); } catch(e) {} try{ window.__outOfLives=false; }catch(e){} const ann = document.getElementById('live-announcer'); if(ann) ann.textContent=''; pickNextRandom(); };
  if(close) close.onclick = () => { overlay.style.display = 'none'; try { window.__outOfLives = false; } catch(e) {}; const ann = document.getElementById('live-announcer'); if(ann) ann.textContent = ''; };
      }

  // Marathon: game over handling
  let lives = 3;
  // input blocking flag
  let blocked = false;
      function spawnLifeExplosion(el){
        try{
          if(!el || !el.getBoundingClientRect) return;
          const rect = el.getBoundingClientRect();
          const layer = getExplosionLayer();

          // small flash only
          layer.classList.add('flash');
          setTimeout(()=>{ layer.classList.remove('flash'); }, 220);

          // clone the life note into the overlay and play pop-burst
          const clone = /** @type {HTMLElement} */ (el.cloneNode(true));
          clone.style.position = 'fixed';
          clone.style.left = Math.round(rect.left) + 'px';
          clone.style.top = Math.round(rect.top) + 'px';
          clone.style.margin = '0';
          clone.style.pointerEvents = 'none';
          clone.style.transformOrigin = 'center';
          clone.style.display = 'inline-flex';
          clone.style.alignItems = 'center';
          clone.style.justifyContent = 'center';
          clone.style.zIndex = '100150';
          clone.classList.add('pop-burst');
          layer.appendChild(clone);

          // spawn SVG-note particles for a richer pop
          const large = 14 + Math.floor(Math.random()*8); // 14-21 particles
          for(let i=0;i<large;i++){
            const p = document.createElement('div');
            p.className = 'life-confetti' + (Math.random()>0.7? ' big':'' );
            p.style.position = 'fixed';
            const startX = Math.round(rect.left + rect.width/2);
            const startY = Math.round(rect.top + rect.height/2);
            p.style.left = startX + 'px';
            p.style.top = startY + 'px';
            const scale = 0.8 + Math.random()*1.4;
            const color = ['%23FFD166','%23FFAB91','%2398FFB5','%239AD1FF'][Math.floor(Math.random()*4)];
            p.innerHTML = `<svg class="note-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z" fill="${color}"/></svg>`;
            layer.appendChild(p);
            const angle = Math.random()*Math.PI*2;
            const dist = 42 + Math.random()*96;
            const dx = Math.cos(angle)*dist * (0.8 + Math.random()*0.8);
            const dy = Math.sin(angle)*dist * (0.8 + Math.random()*0.8) - (8 + Math.random()*12);
            p.style.transform = `translate(0px,0px) scale(${scale}) rotate(0deg)`;
            p.style.transition = (420 + Math.random()*420) + 'ms cubic-bezier(.2,.9,.3,1)';
            const delay = Math.random()*80;
            setTimeout(()=>{ requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ p.style.transform = `translate(${dx}px, ${dy}px) rotate(${(Math.random()*720-360)|0}deg) scale(${0.5 + Math.random()*1.6})`; p.style.opacity = '0'; }); }); }, delay);
            setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 1400 + Math.random()*600);
          }

          // remove clone after animation
          setTimeout(()=>{ try{ clone.remove(); }catch(e){} }, 720);
        }catch(e){ console.warn('spawnLifeExplosion failed', e); }
      }

          function onGameOver(){
            try{ blocked = true; }catch(e){}
            const overlay = document.getElementById('run-overlay');
            const title = document.getElementById('run-title');
            const msg = document.getElementById('run-msg');
            const scoreEl = document.getElementById('run-score');
            const bestEl = document.getElementById('run-best');
            if(!overlay||!scoreEl) return;
            const correct = runCorrect;
            const total = runCount;
      if(title) title.textContent = 'Game Over';
      if(msg) msg.textContent = 'You lost all your lives.';
      if(scoreEl) scoreEl.textContent = String(correct);
            try{
              const key = 'marathon-best';
              const prev = parseInt(localStorage.getItem(key)||'0',10) || 0;
              const badge = document.getElementById('new-high-badge');
              if(correct > prev){ localStorage.setItem(key, String(correct)); if(bestEl) bestEl.textContent = String(correct); if(badge){ badge.classList.add('show'); badge.style.display='inline-block'; setTimeout(()=>{ badge.classList.remove('show'); }, 1400); } }
              else { if(bestEl) bestEl.textContent = String(prev); }
            }catch(e){}
            overlay.style.display = 'flex';
            const restart = document.getElementById('run-restart');
            const close = document.getElementById('run-close');
            if(restart) restart.onclick = ()=>{ overlay.style.display='none'; runCount=0; runCorrect=0; lives=3; blocked=false; try{ resetLifeIcons(); }catch(e){} try{ window.__outOfLives=false; }catch(e){} const ann = document.getElementById('live-announcer'); if(ann) ann.textContent=''; pickNextRandom(); };
            if(close) close.onclick = ()=>{ overlay.style.display='none'; try{ window.__outOfLives=false; }catch(e){} const ann = document.getElementById('live-announcer'); if(ann) ann.textContent=''; };
          }

      function revealComboForCurrent(){
        const currentFilename = String(images[currentIndex]);
        const req = answerKey[currentFilename]||[];
        const buttons = document.querySelectorAll('#gamepad [data-button]');
        buttons.forEach(b=>{if(req.includes(String(b.getAttribute('data-button'))))b.classList.add('gp-hint');});
  if(revealTimeout) clearTimeout(revealTimeout);
  revealTimeout = /** @type {number} */ (setTimeout(()=>{ try{ buttons.forEach(b=>b.classList.remove('gp-hint')); }catch(e){} revealTimeout=null; }, REVEAL_DURATION));
      }

      function checkComboAndAdvance(){
        const filename = String(images[currentIndex]);
        const req = /** @type {string[]} */ (answerKey[filename]||[]);
        console.log('[fingering] checkComboAndAdvance', { currentIndex, filename, req, activeKeys: Array.from(activeKeys), recentPressesLength: recentPresses.length });
        /** @type {Set<string>} */
        const nowKeys = new Set(activeKeys);
        const now = Date.now();
        for(let i=recentPresses.length-1;i>=0;i--){if(now-recentPresses[i].time<=TOUCH_WINDOW) nowKeys.add(recentPresses[i].key); else recentPresses.splice(i,1);}
        const ok = req.every(/** @param {string} k */ (k)=>nowKeys.has(k));
        if(ok){
          triggerCorrect();
          // advance on correct
          advanceToNext();
          activeKeys.clear();
          recentPresses.length=0;
          if(wrongTimeout){ clearTimeout(wrongTimeout); wrongTimeout = null; }
          wrongCounts[filename]=0;
          streak++; localStorage.setItem('fingering-streak', String(streak));
          if(streakEl) streakEl.textContent=String(streak);
          if(streak>best){best=streak; localStorage.setItem('fingering-best', String(best)); if(bestEl) bestEl.textContent=String(best);}
          const streakNode = document.getElementById('streak');
          if(streakNode) streakNode.classList.add('streak-pulse');
          setTimeout(()=>{ const sn = document.getElementById('streak'); if(sn) sn.classList.remove('streak-pulse'); },900);
          return true;
        }
        // If not correct, still advance to next card but keep wrong visuals.
        advanceToNext();
        activeKeys.clear();
        recentPresses.length=0;
        if(wrongTimeout){ clearTimeout(wrongTimeout); wrongTimeout = null; }
        return false;
      }

      function handleWrong(){
        console.log('[fingering] handleWrong scheduling wrong visual (touch window)', { currentIndex, filename: images[currentIndex] });
  if(wrongTimeout) clearTimeout(wrongTimeout);
  const filename = String(images[currentIndex]);
        // Delay slightly to allow multi-key grouping, but when fired, run synchronized visual
        const scheduledFilename = String(images[currentIndex]);
        wrongTimeout = /** @type {number} */ (setTimeout(()=>{
          // If the shown image changed since scheduling, skip â€” counts/reveal are per-card
          if (String(images[currentIndex]) !== scheduledFilename) {
            console.log('[fingering] scheduled wrong skipped because card changed', { scheduledFilename, currentShown: images[currentIndex] });
            wrongTimeout = null;
            return;
          }
          // If a correct animation ran since this timeout was scheduled, skip firing the wrong visual.
          const now2 = Date.now();
          if (now2 - lastCorrectAt < 600) {
            console.log('[fingering] skipped scheduled wrong visual because a correct happened', { now: now2, lastCorrectAt });
            wrongTimeout = null;
            return;
          }
          const pressedBtn = /** @type {HTMLElement|null} */ (document.querySelector('#gamepad .gp-pressed'));
          console.log('[fingering] scheduled wrong visual firing', { now: now2, lastCorrectAt, scheduledFilename });
          triggerWrongVisual(pressedBtn);
          wrongTimeout=null;
  }, Math.max(10, TOUCH_WINDOW)));
      }

      // Keyboard
      window.addEventListener('keydown',e=>{
        let k='';
        if(e.code&&e.code.startsWith('Numpad')) k=e.code.replace('Numpad','');
        else if(e.key&&/^[0-9]$/.test(e.key)) k=e.key;
        if(!k||!['0','1','2','3'].includes(k)) return;
        if(blocked) {
          console.log('[fingering] input ignored (game over)');
          return;
        }
        console.log('[fingering] keydown', k);
        activeKeys.add(k);
        const matched = checkComboAndAdvance();
        if(!matched){
          // determine whether immediate wrong feedback is safe (single-key required)
          const filename = images[currentIndex];
          const req = /** @type {string[]} */ (answerKey[filename] || []);
          if(req.length === 1 && !req.includes(k)){
            // immediate strong feedback for single-key mismatches
            triggerWrongVisual(null);
          } else {
            handleWrong();
          }
        }
      });
      window.addEventListener('keyup',e=>{
        let k='';
        if(e.code&&e.code.startsWith('Numpad')) k=e.code.replace('Numpad','');
        else if(e.key&&/^[0-9]$/.test(e.key)) k=e.key;
        if(!k) return;
        activeKeys.delete(k);
      });

      // Gamepad
      document.querySelectorAll('#gamepad [data-button]').forEach(b=>{
        const key=b.getAttribute('data-button');
        if(!key) return;
        const press=()=>{
          if(blocked) { console.log('[fingering] gamepad input ignored (game over)'); return; }
          console.log('[fingering] gamepad press', key);
          recentPresses.push({key,time:Date.now()});
          const matched = checkComboAndAdvance();
          if(!matched){
            const filename = images[currentIndex];
            const req = /** @type {string[]} */ (answerKey[filename] || []);
            // quick pressed visual
            b.classList.add('gp-pressed');
            setTimeout(()=>b.classList.remove('gp-pressed'), PRESS_DURATION);
            if(req.length === 1 && !req.includes(key)){
              triggerWrongVisual(b);
            } else {
              handleWrong();
            }
          } else {
            // matched: show pressed briefly
            b.classList.add('gp-pressed');
            setTimeout(()=>b.classList.remove('gp-pressed'), PRESS_DURATION);
          }
        }
        b.addEventListener('click',press);
        b.addEventListener('touchstart',e=>{e.preventDefault(); press();},{passive:false});
      });

      // Click image to randomize
      img.addEventListener('click',()=>{
        let next=Math.floor(Math.random()*images.length);
        while(images.length>1&&next===currentIndex) next=Math.floor(Math.random()*images.length);
        currentIndex=next; setImage(currentIndex);
      });
    })();
  </script>
</Layout>
